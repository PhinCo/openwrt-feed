#!/bin/sh /etc/rc.common

START=99
USE_PROCD=1

BINFILE="/opt/phin/bridge"
FIRMWARE="/opt/phin/firmware"
ADMIN="/opt/phin/admin"
BINOPTS="-F"

UNLOCK="/opt/phin/unlock"       # calling unlock sends running bridge a signal to stop and cleanup before exiting

POST_UPDATE_SCRIPT="/opt/phin/post-update-script.ash"

post_update_installation() {
  LAST_BOOTED_VERSION_FILE="/etc/phin-last-booted-version.txt"
  PHIN_VERSION_FILE="/etc/phin_version"
  UPDATE_INSTALL_SCRIPT="/opt/phin/update-script"
  VERSION=$(cat ${PHIN_VERSION_FILE} | sed -r 's/^version=([0-9]+\.[0-9]+\.[0-9]+).*/\1/g')

  ## Check if this is the first time this bridge has run this version
  if [[ -f ${LAST_BOOTED_VERSION_FILE} ]] ; then
    LAST_BOOTED_VERSION=$(cat ${LAST_BOOTED_VERSION_FILE})
  else
    LAST_BOOTED_VERSION="unknown"
  fi

  ## Handle post firmware update installation with script
  if [[ ${VERSION} != ${LAST_BOOTED_VERSION} ]] ; then
    if [[ -f ${POST_UPDATE_SCRIPT} ]] ; then
      ${POST_UPDATE_SCRIPT}
    fi
  fi

  echo ${VERSION} > ${LAST_BOOTED_VERSION_FILE}
}

set_cron() {
  AUTO_REBOOTED_FILE="/etc/phin-auto-rebooted.txt"
  CRON_TAB_FILE="/etc/crontabs/root"

  if [[ ! -f ${AUTO_REBOOTED_FILE} || ! -f ${CRON_TAB_FILE} ]]; then
    echo "PREPARING CRON"
    echo "never" > ${AUTO_REBOOTED_FILE}
    RANDMIN=$(awk -v min=0 -v max=59 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')   # minute 0 to min 59
    RANDHR=$(awk -v min=7 -v max=9 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')     # approx CA 12am to 2am
    CRONTIME="${RANDMIN} ${RANDHR}"
    echo "SETTING CRON RESTART AS: ${CRONTIME} UTC"
    echo ${CRONTIME} '* * * sleep 60 && touch /etc/banner && date >' ${AUTO_REBOOTED_FILE} '&&' ${UNLOCK} '; sleep 10 ; reboot' > ${CRON_TAB_FILE}
  fi
}

disable_ap() {
  uci set wireless.@wifi-iface[0].disabled='1'
  uci commit wireless
  wifi
}

start_service() {
  post_update_installation
  set_cron

  procd_open_instance phin_bridge
  procd_set_param command ${BINFILE} ${BINOPTS} -i ${FIRMWARE} -a ${ADMIN}

  # respawn automatically if something died, be careful if you have an alternative process supervisor
  procd_set_param respawn 3600 20 0

  # procd_set_param env SOME_VARIABLE=funtimes  # pass environment variables to your process
  procd_set_param stdout 1 # forward stdout of the command to logd
  procd_set_param stderr 1 # same for stderr
  procd_close_instance
}

stop_service() {
  echo "Stopping bridge"
  ${UNLOCK}
}
